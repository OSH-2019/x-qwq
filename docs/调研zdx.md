# 调研

## Fuchsia

### Fuchsia的简介与设计架构

2016年8月，一个名为"Fuchsia"的项目突然出现在Github上，这是Fuchsia第一次出现在公众面前。Fuchsia取名意为“紫红”，是Google开发的一个新型、现代的操作系统。在它之前，Google公司在操作系统方面的项目只有Android和Chrome OS两个；前者占据了全球移动端操作系统的半壁江山，而后者则主要运行在Google公司推出的Chromebook笔记本电脑上，是一种基于web和云端的操作系统。

与Android和Chrome OS不同的是，这两个操作系统都是基于Linux内核开发的，而Fuchsia则使用了不同于Linux的全新内核——Zircon。Zircon是基于Little Kernel(LK)开发的；LK是一个用于嵌入式设备的小型操作系统，代码很少，设计也比较简单，并且被一些厂家用于Android的bootload。

与Linux不同的地方在于，Zircon采用了微内核架构。在操作系统内核的结构设计上，微内核/宏内核之争由来已久：宏内核主张将内核的主要功能集成在一起运行，效率较高，但功能之间的耦合较紧，如果其中一个部分发生崩溃可能会带来严重的后果。微内核则将内核的大部分功能独立出去，成为模块，内核本身只提供最基础的设施以及模块之间的通信功能，使得模块之间比较独立，便于开发，也具有更好的健壮性。不论这两种架构孰优孰劣，较新的操作系统内核更多的还是采用了微内核架构——Zircon也是其中之一。在Zircon中，内核态的程序只提供内存管理、进程管理、IPC、中断处理等非常基础的功能；而I/O设备管理、文件系统等等功能则放在用户态的模块中进行。

Fuchsia操作系统并不只有一个内核。此系统被设计成了分级的四层架构：最底层是内核Zircon，然后是系统服务层Garnet，接着是用户服务层Peridot，最后是应用层Topaz。Google还为这个系统开发了一套UI设计框架Flutter，它也运行在Topaz层上。

值得注意的是，Garnet层的一部分组件用到了rust编程语言，是少数用到了rust的操作系统项目。用到了rust的组件包括蓝牙模块、xi编辑器的核心xi_core等等。不过，Zircon内核仍然没有使用到rust编程语言，而是主要由C/C++来编写。

Fuchsia是开源操作系统。Fuchsia的绝大多数源代码在googlesource网站上公开，并由它的团队进行维护。Github上曾经也维护了Fuchsia的源代码镜像，但在2018年12月被撤走，原因不明。

Fuchsia的源代码可以被编译到x86和ARM两套指令集，因此有人认为它可能打算统一PC和移动平台。Fuchsia目前并不支持运行在主流的机器上面；但它支持谷歌的Pixelbook和Intel NUC（一种迷你的电脑），还可以在qemu上运行或调试。

总体而言，Fuchsia作为Google开发的操作系统，其目的还不是很明确，推测可能是Google希望有一个摆脱Linux内核的系统，或是希望能创造出一个统一手机/PC的操作系统平台。而且Fuchsia的特点也不是很清晰，没有什么具有革命性的新特点。但是Fuchsia并不成熟，仍然在不断的开发当中；未来或许能成为Android的替代品，所以Fuchsia的前景也不容小觑（实际上Google已经开始着手向Fuchsia添加关于Android的一部分支持）。

### Fuchsia中的线程调度和IPC

为了更深入地了解Fuchsia工作机制，就需要了解Fuchsia中的进程/线程机制。我个人认为要用rust修改Zircon中的某些功能的话，线程调度和IPC是比较好的选择，因为它们逻辑比较清晰，也不是太过底层。

Fuchsia的调度算法在`kernel/kernel/sched.cpp`下面。`sched_init_early`函数用于最开始内核对调度队列进行初始化，可以看出内核会给每个CPU设置若干不同优先级的链表（队列）。`sched_resched_internal`函数负责在发生线程阻塞、主动放弃时间片(10ms)、因为中断而被抢占（包括时间片耗尽）、主动要求重新调度CPU等情况之后，进行线程的重新调度；在这个函数中，调度的核心是调用`sched_get_top_thread`函数，它会找出CPU中最高优先级的调度队列，并将队头出队。此外，如果线程被设置为是实时的(real_time)，那么它将不会被抢占。此外，时间片耗尽会导致线程的优先级下降。

可以看到，Fuchsia的调度算法基本比较简单，和课本第5章所描述的多级反馈队列调度比较相像，但增加了对于不被抢占的实时线程的支持。

内核模块也提供了IPC相关机制。`kernel/kernel/mutex.cpp`提供了基本的互斥锁，实现了`acquire`和`release`方法，而且其思路和课本6.5节基本一致。除了互斥锁，`kernel/object/semaphore.cpp`也提供了信号量，实现了`wait`和`post`(signal)方法，属于记录型信号量（会记录等待获取资源的队列，并选择合适的时机阻塞或唤起）。

但是Fuchsia似乎并没有使用上面的机制。按照官方文档所说，为了实现IPC的效率、确定性、健壮性、易用性，Fuchsia使用了一种特殊的描述语言——FIDL（Fuchsia接口定义语言）来描述IPC。这样的话，编写应用程序时就不需要关心底层的实现，而可以直接使用FIDL来抽象地描述IPC，最后通过fidlc编译器编译到所使用的编程语言的代码（包括C,C++,Dart和Rust）。在FIDL的模型中，两个应用程序（客户端与服务端）位于上层，而底层会使用"channel"进行通信。从内核代码上看，在`kernel/object/`下面有`channel_dispatcher.cpp` `process_dispatcher.cpp`等文件，实现进程间消息的派发，所以推测它们可能类似于管程，用来实现IPC。

### Fuchsia中的namespace

与通常的操作系统不同，Fuchsia提出了命名空间(namespace)，作为进程访问权限的依据。虽然namespace的概念在很多地方都有出现，但与这里不同。

从某种意义上说，namespace是对根文件系统的一种抽象。因为Zircon是微内核架构，所以文件系统从内核中分离出去了，成为了单独的模块，并使用Fuchsia中的IPC机制进行文件的访问。文件系统成为了一种接口，这样就带来了文件系统的抽象：Fuchsia中将文件、服务、设备等等对象抽象为了不同的namespace。比如，`/bin`并不一定代表根目录下的bin文件夹，而可能代表一个名字叫bin的namespace，通过它对应的进程所提供的句柄进行操作。（这似乎与Redox中的URL抽象有类似之处）

namespace为Fuchsia提供了一定的安全性的保证。相比于使用用户和用户组来控制文件的各种权限的Linux系统，在Fuchsia中没有用户的概念，进程的权限由namespace来控制。这样，传统的利用用户机制提权的攻击方法就不起效。Fuchsia中也不存在全局的文件系统，不能随意使用`..`来访问上级目录。 

## Rust

### Rust的特点和使用意义

Rust是一门新兴的编程语言。Rust出现于2014年，在2015年正式推出1.0版本，现如今已经到1.33版本了。Rust一经面世便引起了广泛关注，在2016~2018三年被连续评为Stack Overflow上最受喜爱的编程语言。目前，Rust已经有了一个成熟的团队进行开发，并且计划专攻命令行界面、嵌入式设备、网络、WebAssembly四个方向。此外，Rust是开源的编程语言，Rust的编译器基于llvm开发，可以轻易转换成各种平台上的二进制。

Rust具有什么特点？官方给出的答案是高性能、可靠、易用。

Rust在设计上类似C++，遵守“零抽象原则”，也就是会在不损失效率的前提下才会进行抽象。因此，Rust程序往往具有很高的性能，例如用Rust编写的Web框架actix，其实现效率与同类型框架相比排名第一。（ https://www.techempower.com/benchmarks/#section=data-r16&hw=ph&test=plaintext ）

Rust又在C++的基础上，提出了所有权与生命周期的概念。所有权的概念在C++中就有提出，主要是针对原生指针带来的潜在问题（引用空指针、忘记释放、多次释放、多线程冲突等）。C++为了解决这些问题而提供了智能指针：将在堆上申请的对象视为一种资源，根据资源是独占还是共享（即资源的所有权），分别提供`unique_ptr`和`shared_ptr`实现自动分配/释放。生命周期则是在软件中非常常见的概念，在这里专指Rust中的对象从生存到销毁所经历的时间。Rust不仅继承了所有权和生命周期的思想，还将这一思想具体化、强制化，也就是Rust程序（在safe的前提下）必须满足编译器规定的关于所有权和生命周期的规定。例如，对象的所有者可以将它的所有权借用给其他的函数，但要求同一时刻只能有多个不可变借用（只读），或是至多一个可变借用（可写），这样便保证了多线程环境下不会有冲突的问题。类似的规定还有很多，这些规定使得Rust相比于C++的放任自由，更强调程序不会出错。

Rust在制作之初就非常关注它的易用性。Rust的文档齐全，编译器友好且能够给出有用的错误信息（感觉是在对比C++编译器对模板的报错），并且有完善的包管理/构建工具。Rust还提供了用于编辑器的智能工具，包括自动补全、自动格式化、类型检查等等。

使用Rust的意义在哪？在于Rust和其他语言的不同之处——也就是前面的三个特点。毫无疑问，Rust和C++有类似之处，很多C++面向的场合也是Rust面向的场合。此外，因为Rust独特的所有权/生命周期系统，使得Rust可以用在对程序可靠性有高要求的场合（例如航天项目、自动驾车等？）。Rust官方也给出了他们所认为的四个重要方向（已经写在前面了）。

### Rust与操作系统

因为Rust被设计成可以运行在裸金属上的程序语言，所以Rust也可以用于操作系统。Rust没有GC，没有厚重的运行时环境；通过编译器选项也可以关闭依赖于宿主系统的标准库。这使得Rust具有了独立运行的能力，也具有了编写操作系统的能力。

在操作系统这一层面，Rust的意义在于它在提供了众多抽象工具（例如其函数式编程的语法）的同时，又能保证程序具有一定的健壮性——对于软件世界的“地基”操作系统，稳健是非常重要的特性。

但Rust用于操作系统的意义却并不突出，这是因为Rust所要求的很多规则，在操作系统的层面往往不能完全遵守。为此，需要在Rust程序中显式地告诉编译器——这段代码是不安全(unsafe)的，Rust所引以为傲的可靠性便失去了意义。此外，在操作系统的层面，很多抽象工具并不是必要的。所以用Rust写操作系统，有好处也有坏处。

目前，有一个使用Rust编写的类UNIX操作系统Redox，可以在真机上运行，并且具有GUI界面，印证了Rust编写操作系统的能力。虽然目前Redox操作系统还是以玩具性质为主，但它还是以成为下一代的操作系统为目标。并且Redox也提出了一些新颖的想法，如“一切皆URL”，即通过URL的形式统一了文件资源和网络资源。
